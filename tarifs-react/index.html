<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pseudo-loop Swiper</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@9/swiper-bundle.min.css" />
  <style>
    body { font-family: Inter, system-ui, sans-serif; padding: 40px; box-sizing: border-box; }
    .swiper { width: 83.3%; margin: 0 auto; }
    .swiper-wrapper { perspective: 1000px; }

    .swiper-slide {
      width: 320px;
      height: 480px;
      flex: 0 0 auto;
      box-sizing: border-box;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 6px 20px rgba(0,0,0,0.12);
    }

    /* Карточка (двусторонняя) */
    .card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
      cursor: pointer;
    }
    .card-inner.is-flipped { transform: rotateY(180deg); }

    .swiper-slide-front,
    .swiper-slide-back {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      font-weight: 700;
      font-size: 20px;
    }

    /* фронт/бек (контрастные цвета, чтобы текст был виден) */
    .swiper-slide-front { background: linear-gradient(180deg,#7bd389,#4aa86b); color: #fff; }
    .swiper-slide-back  { background: linear-gradient(180deg,#7be9ff,#3fb1c9); color: #033; transform: rotateY(180deg); }

    /* делаем пагинацию чуть ниже */
    .swiper-pagination { margin-top: 18px; }

    /* адаптив */
    @media (max-width: 900px) {
      .swiper-slide { width: 280px; height: 420px; }
    }
    @media (max-width: 520px) {
      .swiper-slide { width: 220px; height: 340px; }
    }
  </style>
</head>

<body>
  <h2>Псевдо-loop Swiper — клик → центр → flip</h2>

  <div class="swiper">
    <div class="swiper-wrapper">
      <div class="swiper-slide">
        <div class="card-inner">
          <div class="swiper-slide-front">Slide 1 front</div>
          <div class="swiper-slide-back">Slide 1 back</div>
        </div>
      </div>

      <div class="swiper-slide">
        <div class="card-inner">
          <div class="swiper-slide-front">Slide 2 front</div>
          <div class="swiper-slide-back">Slide 2 back</div>
        </div>
      </div>

      <div class="swiper-slide">
        <div class="card-inner">
          <div class="swiper-slide-front">Slide 3 front</div>
          <div class="swiper-slide-back">Slide 3 back</div>
        </div>
      </div>

      <div class="swiper-slide">
        <div class="card-inner">
          <div class="swiper-slide-front">Slide 4 front</div>
          <div class="swiper-slide-back">Slide 4 back</div>
        </div>
      </div>

      <div class="swiper-slide">
        <div class="card-inner">
          <div class="swiper-slide-front">Slide 5 front</div>
          <div class="swiper-slide-back">Slide 5 back</div>
        </div>
      </div>

      <div class="swiper-slide">
        <div class="card-inner">
          <div class="swiper-slide-front">Slide 6 front</div>
          <div class="swiper-slide-back">Slide 6 back</div>
        </div>
      </div>
    </div>

    <!-- пагинация -->
    <div class="swiper-pagination"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/swiper@9/swiper-bundle.min.js"></script>
  <script>
    /*
      Псевдо-loop реализация:
      - loop: false (мы ручками будем перемещать слайды в DOM)
      - slidesPerView: 'auto', centeredSlides: true (peek эффект)
      - при клике на боковой слайд: сначала slideTo, дождаться transitionEnd,
        затем, при необходимости, переместить DOM (append/prepend) и синхронизировать Swiper без анимации,
        затем сделать flip центрального слайда.
    */

    const swiper = new Swiper('.swiper', {
      loop: false,
      slidesPerView: 'auto',
      centeredSlides: true,
      spaceBetween: 40,
      speed: 300,
      pagination: { el: '.swiper-pagination', clickable: true },
    });

    // удобные ссылки
    const wrapper = swiper.wrapperEl; // .swiper-wrapper
    const slides = () => Array.from(wrapper.querySelectorAll('.swiper-slide'));

    let isAnimating = false;        // блокировка для предотвращения конфликтов
    let clickedSlideRef = null;     // какую карточку кликнули (DOM element)
    let pendingDirection = null;    // 'next' или 'prev' — если нужно переставление DOM после перехода

    function disableInteraction() {
      isAnimating = true;
      swiper.allowSlideNext = false;
      swiper.allowSlidePrev = false;
    }
    function enableInteraction() {
      isAnimating = false;
      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
    }

    // закроем все флипы
    function closeAllFlips() {
      wrapper.querySelectorAll('.card-inner.is-flipped').forEach(inner => inner.classList.remove('is-flipped'));
    }

    // сделает flip для переданного слайда (DOM node)
    function flipSlideNode(slideEl) {
      if (!slideEl) return;
      const inner = slideEl.querySelector('.card-inner');
      if (!inner) return;
      closeAllFlips();
      inner.classList.add('is-flipped');
      disableInteraction();
    }

    // получить "реальный" индекс слайда среди текущих слайдов (0..N-1)
    function realIndexOf(slideEl) {
      return slides().indexOf(slideEl);
    }

    // навешивание кликов на слайды
    function attachSlideClicks() {
      slides().forEach(slide => {
        // удаляем старый слушатель если был
        if (slide._pseudoHandler) slide.removeEventListener('click', slide._pseudoHandler);

        const handler = (e) => {
          if (isAnimating) return;
          const clicked = e.currentTarget;

          // DOM-элемент активного слайда (тот, что центрирован)
          const activeSlide = swiper.slides[swiper.activeIndex];

          // если кликнули по центральному слайду — сразу переворачиваем/закрываем
          if (clicked === activeSlide) {
            const inner = clicked.querySelector('.card-inner');
            if (inner.classList.contains('is-flipped')) {
              inner.classList.remove('is-flipped');
              enableInteraction();
            } else {
              closeAllFlips();
              inner.classList.add('is-flipped');
              disableInteraction();
            }
            return;
          }

          // клик по боковой карточке -> двигаем сперва к ней
          clickedSlideRef = clicked;
          disableInteraction();

          // определить направление относительно активного
          const activeIdx = swiper.slides.indexOf(activeSlide);
          const clickedIdx = swiper.slides.indexOf(clicked);

          // защита: если не нашли индекс (должно быть найдено), используем realIndex
          let dir;
          if (clickedIdx === -1 || activeIdx === -1) {
            // fallback: сравниваем реальные индексы
            const rClicked = realIndexOf(clicked);
            const rActive = realIndexOf(activeSlide);
            dir = (rClicked > rActive) ? 'next' : 'prev';
          } else {
            dir = (clickedIdx > activeIdx) ? 'next' : 'prev';
          }
          pendingDirection = dir;

          // плавно прокручиваем к clicked (slideTo по DOM-индексу)
          // slideTo принимает индекс в текущем массиве swiper.slides
          swiper.slideTo(clickedIdx, swiper.params.speed);
          // flip произойдёт в обработчике transitionEnd
        };

        slide.addEventListener('click', handler);
        slide._pseudoHandler = handler;
      });
    }

    // когда transition закончился — делаем возможную перестановку DOM и flip
    swiper.on('transitionEnd', () => {
      // если не было клика — просто разблокируем
      if (!clickedSlideRef) {
        enableInteraction();
        return;
      }

      const currentSlides = slides();
      const activeDomIndex = swiper.activeIndex;

      // Если шли вправо и активный индекс близок к концу — перемещаем первый в конец
      if (pendingDirection === 'next') {
        if (activeDomIndex >= currentSlides.length - 2) {
          wrapper.appendChild(currentSlides[0]);
          swiper.update(); // пересобираем внутренний массив
          // скорректируем позицию мгновенно (без анимации)
          const newIndex = Math.max(0, swiper.activeIndex - 1);
          swiper.slideTo(newIndex, 0);
        }
      } else if (pendingDirection === 'prev') {
        // если шли влево и активный индекс близок к началу — перемещаем последний в начало
        if (activeDomIndex <= 1) {
          const last = currentSlides[currentSlides.length - 1];
          wrapper.insertBefore(last, currentSlides[0]);
          swiper.update();
          const newIndex = Math.min(swiper.slides.length - 1, swiper.activeIndex + 1);
          swiper.slideTo(newIndex, 0);
        }
      }

      // Теперь, если кликнутый слайд стал активным — делаем flip
      const activeSlide = swiper.slides[swiper.activeIndex];
      if (clickedSlideRef === activeSlide) {
        closeAllFlips();
        const inner = activeSlide.querySelector('.card-inner');
        if (inner) inner.classList.add('is-flipped');
        // оставляем interaction заблокированным — пользователь закроет карточку кликом по ней
      } else {
        // в редком случае если не совпало — просто разблокируем
        enableInteraction();
      }

      // очистка
      clickedSlideRef = null;
      pendingDirection = null;
    });

    // навесим клики при стартовой инициализации
    attachSlideClicks();

    // при обновлении (если мы переставляли слайды) — заново навесим обработчики
    swiper.on('update', () => {
      attachSlideClicks();
      enableInteraction();
    });

    // опционально — защита от быстрого ресайза/многокликов (debounce)
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        swiper.update();
      }, 120);
    });
  </script>
</body>
</html>
